{"ast":null,"code":"var _jsxFileName = \"D:\\\\Collabryta\\\\collabryta-frontend\\\\src\\\\context\\\\NotificationContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { notificationService } from '../services/notificationService';\nimport { authService } from '../services/authService';\nimport { Bell, CheckCircle, Info, AlertTriangle, AlertCircle } from 'lucide-react';\n\n/**\r\n * Context interface for managing global application notifications.\r\n */\n\nconst NotificationContext = /*#__PURE__*/createContext(undefined);\nimport { webSocketService } from '../services/websocketService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [toast, setToast] = useState(null);\n  const showToast = useCallback((title, message, type = 'info') => {\n    setToast({\n      title,\n      message,\n      type\n    });\n    setTimeout(() => setToast(null), 5000);\n  }, []);\n  const fetchNotifications = useCallback(async () => {\n    if (!authService.isAuthenticated()) return;\n    try {\n      const data = await notificationService.getNotifications(0, 50);\n      setNotifications(data);\n      setUnreadCount(data.filter(n => !n.is_read).length);\n    } catch (err) {\n      console.error('Error fetching notifications:', err);\n    }\n  }, []);\n  const addNotification = useCallback(notification => {\n    setNotifications(prev => {\n      // Check if notification already exists to avoid duplicates\n      if (prev.some(n => n.id === notification.id)) return prev;\n\n      // Show toast for new live notifications\n      showToast(notification.title, notification.description, notification.type);\n      return [notification, ...prev];\n    });\n    setUnreadCount(prev => prev + 1);\n  }, [showToast]);\n  const handleWebSocketMessage = useCallback(message => {\n    console.log('Received WebSocket message:', message);\n    switch (message.type) {\n      case 'notification':\n        addNotification(message.data);\n        break;\n      case 'message':\n        showToast('New Message', message.data.content, 'info');\n        break;\n      case 'task':\n        // The backend might already send a notification for task creation/update\n        // If not, we could show a toast here. \n        // Based on my backend changes, I send BOTH.\n        // So I'll let the 'notification' case handle the toast to avoid double toast.\n        break;\n      case 'meeting':\n      case 'file':\n        break;\n      default:\n        break;\n    }\n  }, [addNotification, showToast]);\n  const markAsRead = async id => {\n    try {\n      await notificationService.markAsRead(id);\n      setNotifications(prev => prev.map(n => n.id === id ? {\n        ...n,\n        is_read: true\n      } : n));\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    } catch (err) {\n      console.error('Error marking notification as read:', err);\n    }\n  };\n  const markAllAsRead = async () => {\n    try {\n      await notificationService.markAllAsRead();\n      setNotifications(prev => prev.map(n => ({\n        ...n,\n        is_read: true\n      })));\n      setUnreadCount(0);\n    } catch (err) {\n      console.error('Error marking all notifications as read:', err);\n    }\n  };\n  useEffect(() => {\n    if (authService.isAuthenticated()) {\n      fetchNotifications();\n      const token = localStorage.getItem('token');\n      if (token) {\n        webSocketService.connect(token);\n        const unsubscribe = webSocketService.subscribe(handleWebSocketMessage);\n        return () => {\n          unsubscribe();\n          // We don't necessarily want to disconnect here if the component unmounts/remounts\n          // but since NotificationProvider is usually top-level, it's fine.\n        };\n      }\n    } else {\n      webSocketService.disconnect();\n    }\n  }, [fetchNotifications, handleWebSocketMessage]);\n  const getIconForToastType = type => {\n    switch (type) {\n      case 'success':\n        return /*#__PURE__*/_jsxDEV(CheckCircle, {\n          className: \"h-5 w-5 text-green-500\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 124,\n          columnNumber: 36\n        }, this);\n      case 'info':\n        return /*#__PURE__*/_jsxDEV(Info, {\n          className: \"h-5 w-5 text-blue-500\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 125,\n          columnNumber: 33\n        }, this);\n      case 'warning':\n        return /*#__PURE__*/_jsxDEV(AlertTriangle, {\n          className: \"h-5 w-5 text-yellow-500\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 36\n        }, this);\n      case 'error':\n        return /*#__PURE__*/_jsxDEV(AlertCircle, {\n          className: \"h-5 w-5 text-red-500\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 127,\n          columnNumber: 34\n        }, this);\n      default:\n        return /*#__PURE__*/_jsxDEV(Bell, {\n          className: \"h-5 w-5 text-gray-500\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 128,\n          columnNumber: 29\n        }, this);\n    }\n  };\n  const getBorderColorForToastType = type => {\n    switch (type) {\n      case 'success':\n        return 'border-green-500';\n      case 'info':\n        return 'border-blue-500';\n      case 'warning':\n        return 'border-yellow-500';\n      case 'error':\n        return 'border-red-500';\n      default:\n        return 'border-gray-300';\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: {\n      notifications,\n      unreadCount,\n      addNotification,\n      markAsRead,\n      markAllAsRead,\n      refresh: fetchNotifications\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 143,\n    columnNumber: 9\n  }, this);\n};\n_s(NotificationProvider, \"47tHmt4XYuHNwSJHV7GAdlt4UVU=\");\n_c = NotificationProvider;\nexport const useNotifications = () => {\n  _s2();\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n_s2(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","notificationService","authService","Bell","CheckCircle","Info","AlertTriangle","AlertCircle","NotificationContext","undefined","webSocketService","jsxDEV","_jsxDEV","NotificationProvider","children","_s","notifications","setNotifications","unreadCount","setUnreadCount","toast","setToast","showToast","title","message","type","setTimeout","fetchNotifications","isAuthenticated","data","getNotifications","filter","n","is_read","length","err","console","error","addNotification","notification","prev","some","id","description","handleWebSocketMessage","log","content","markAsRead","map","Math","max","markAllAsRead","token","localStorage","getItem","connect","unsubscribe","subscribe","disconnect","getIconForToastType","className","fileName","_jsxFileName","lineNumber","columnNumber","getBorderColorForToastType","Provider","value","refresh","_c","useNotifications","_s2","context","Error","$RefreshReg$"],"sources":["D:/Collabryta/collabryta-frontend/src/context/NotificationContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\r\nimport { notificationService, Notification } from '../services/notificationService';\r\nimport { authService } from '../services/authService';\r\nimport { Bell, CheckCircle, Info, AlertTriangle, AlertCircle, X } from 'lucide-react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\n/**\r\n * Context interface for managing global application notifications.\r\n */\r\ninterface NotificationContextType {\r\n    notifications: Notification[];\r\n    unreadCount: number;\r\n    addNotification: (notification: Notification) => void;\r\n    markAsRead: (id: number) => Promise<void>;\r\n    markAllAsRead: () => Promise<void>;\r\n    refresh: () => Promise<void>;\r\n    showToast: (title: string, message: string, type?: 'info' | 'success' | 'warning' | 'error') => void;\r\n}\r\n\r\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\r\n\r\nimport { webSocketService, WebSocketMessage } from '../services/websocketService';\r\n\r\nexport const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n    const [notifications, setNotifications] = useState<Notification[]>([]);\r\n    const [unreadCount, setUnreadCount] = useState(0);\r\n    const [toast, setToast] = useState<{ title: string; message: string; type: string } | null>(null);\r\n\r\n    const showToast = useCallback((title: string, message: string, type: 'info' | 'success' | 'warning' | 'error' = 'info') => {\r\n        setToast({ title, message, type });\r\n        setTimeout(() => setToast(null), 5000);\r\n    }, []);\r\n\r\n    const fetchNotifications = useCallback(async () => {\r\n        if (!authService.isAuthenticated()) return;\r\n\r\n        try {\r\n            const data = await notificationService.getNotifications(0, 50);\r\n            setNotifications(data);\r\n            setUnreadCount(data.filter(n => !n.is_read).length);\r\n        } catch (err) {\r\n            console.error('Error fetching notifications:', err);\r\n        }\r\n    }, []);\r\n\r\n    const addNotification = useCallback((notification: Notification) => {\r\n        setNotifications(prev => {\r\n            // Check if notification already exists to avoid duplicates\r\n            if (prev.some(n => n.id === notification.id)) return prev;\r\n\r\n            // Show toast for new live notifications\r\n            showToast(notification.title, notification.description, notification.type);\r\n\r\n            return [notification, ...prev];\r\n        });\r\n        setUnreadCount(prev => prev + 1);\r\n    }, [showToast]);\r\n\r\n    const handleWebSocketMessage = useCallback((message: WebSocketMessage) => {\r\n        console.log('Received WebSocket message:', message);\r\n\r\n        switch (message.type) {\r\n            case 'notification':\r\n                addNotification(message.data as Notification);\r\n                break;\r\n            case 'message':\r\n                showToast('New Message', message.data.content, 'info');\r\n                break;\r\n            case 'task':\r\n                // The backend might already send a notification for task creation/update\r\n                // If not, we could show a toast here. \r\n                // Based on my backend changes, I send BOTH.\r\n                // So I'll let the 'notification' case handle the toast to avoid double toast.\r\n                break;\r\n            case 'meeting':\r\n            case 'file':\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }, [addNotification, showToast]);\r\n\r\n    const markAsRead = async (id: number) => {\r\n        try {\r\n            await notificationService.markAsRead(id);\r\n            setNotifications(prev => prev.map(n => n.id === id ? { ...n, is_read: true } : n));\r\n            setUnreadCount(prev => Math.max(0, prev - 1));\r\n        } catch (err) {\r\n            console.error('Error marking notification as read:', err);\r\n        }\r\n    };\r\n\r\n    const markAllAsRead = async () => {\r\n        try {\r\n            await notificationService.markAllAsRead();\r\n            setNotifications(prev => prev.map(n => ({ ...n, is_read: true })));\r\n            setUnreadCount(0);\r\n        } catch (err) {\r\n            console.error('Error marking all notifications as read:', err);\r\n        }\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (authService.isAuthenticated()) {\r\n            fetchNotifications();\r\n\r\n            const token = localStorage.getItem('token');\r\n            if (token) {\r\n                webSocketService.connect(token);\r\n                const unsubscribe = webSocketService.subscribe(handleWebSocketMessage);\r\n                return () => {\r\n                    unsubscribe();\r\n                    // We don't necessarily want to disconnect here if the component unmounts/remounts\r\n                    // but since NotificationProvider is usually top-level, it's fine.\r\n                };\r\n            }\r\n        } else {\r\n            webSocketService.disconnect();\r\n        }\r\n    }, [fetchNotifications, handleWebSocketMessage]);\r\n\r\n    const getIconForToastType = (type: string) => {\r\n        switch (type) {\r\n            case 'success': return <CheckCircle className=\"h-5 w-5 text-green-500\" />;\r\n            case 'info': return <Info className=\"h-5 w-5 text-blue-500\" />;\r\n            case 'warning': return <AlertTriangle className=\"h-5 w-5 text-yellow-500\" />;\r\n            case 'error': return <AlertCircle className=\"h-5 w-5 text-red-500\" />;\r\n            default: return <Bell className=\"h-5 w-5 text-gray-500\" />;\r\n        }\r\n    };\r\n\r\n    const getBorderColorForToastType = (type: string) => {\r\n        switch (type) {\r\n            case 'success': return 'border-green-500';\r\n            case 'info': return 'border-blue-500';\r\n            case 'warning': return 'border-yellow-500';\r\n            case 'error': return 'border-red-500';\r\n            default: return 'border-gray-300';\r\n        }\r\n    };\r\n\r\n    return (\r\n        <NotificationContext.Provider value={{\r\n            notifications,\r\n            unreadCount,\r\n            addNotification,\r\n            markAsRead,\r\n            markAllAsRead,\r\n            refresh: fetchNotifications\r\n        }}>\r\n            {children}\r\n        </NotificationContext.Provider>\r\n    );\r\n};\r\n\r\nexport const useNotifications = () => {\r\n    const context = useContext(NotificationContext);\r\n    if (context === undefined) {\r\n        throw new Error('useNotifications must be used within a NotificationProvider');\r\n    }\r\n    return context;\r\n};\r\n"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AAC1F,SAASC,mBAAmB,QAAsB,iCAAiC;AACnF,SAASC,WAAW,QAAQ,yBAAyB;AACrD,SAASC,IAAI,EAAEC,WAAW,EAAEC,IAAI,EAAEC,aAAa,EAAEC,WAAW,QAAW,cAAc;;AAGrF;AACA;AACA;;AAWA,MAAMC,mBAAmB,gBAAGZ,aAAa,CAAsCa,SAAS,CAAC;AAEzF,SAASC,gBAAgB,QAA0B,8BAA8B;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAElF,OAAO,MAAMC,oBAA6D,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAC3F,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGnB,QAAQ,CAAiB,EAAE,CAAC;EACtE,MAAM,CAACoB,WAAW,EAAEC,cAAc,CAAC,GAAGrB,QAAQ,CAAC,CAAC,CAAC;EACjD,MAAM,CAACsB,KAAK,EAAEC,QAAQ,CAAC,GAAGvB,QAAQ,CAA0D,IAAI,CAAC;EAEjG,MAAMwB,SAAS,GAAGtB,WAAW,CAAC,CAACuB,KAAa,EAAEC,OAAe,EAAEC,IAA8C,GAAG,MAAM,KAAK;IACvHJ,QAAQ,CAAC;MAAEE,KAAK;MAAEC,OAAO;MAAEC;IAAK,CAAC,CAAC;IAClCC,UAAU,CAAC,MAAML,QAAQ,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC;EAC1C,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMM,kBAAkB,GAAG3B,WAAW,CAAC,YAAY;IAC/C,IAAI,CAACE,WAAW,CAAC0B,eAAe,CAAC,CAAC,EAAE;IAEpC,IAAI;MACA,MAAMC,IAAI,GAAG,MAAM5B,mBAAmB,CAAC6B,gBAAgB,CAAC,CAAC,EAAE,EAAE,CAAC;MAC9Db,gBAAgB,CAACY,IAAI,CAAC;MACtBV,cAAc,CAACU,IAAI,CAACE,MAAM,CAACC,CAAC,IAAI,CAACA,CAAC,CAACC,OAAO,CAAC,CAACC,MAAM,CAAC;IACvD,CAAC,CAAC,OAAOC,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAAC,+BAA+B,EAAEF,GAAG,CAAC;IACvD;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMG,eAAe,GAAGtC,WAAW,CAAEuC,YAA0B,IAAK;IAChEtB,gBAAgB,CAACuB,IAAI,IAAI;MACrB;MACA,IAAIA,IAAI,CAACC,IAAI,CAACT,CAAC,IAAIA,CAAC,CAACU,EAAE,KAAKH,YAAY,CAACG,EAAE,CAAC,EAAE,OAAOF,IAAI;;MAEzD;MACAlB,SAAS,CAACiB,YAAY,CAAChB,KAAK,EAAEgB,YAAY,CAACI,WAAW,EAAEJ,YAAY,CAACd,IAAI,CAAC;MAE1E,OAAO,CAACc,YAAY,EAAE,GAAGC,IAAI,CAAC;IAClC,CAAC,CAAC;IACFrB,cAAc,CAACqB,IAAI,IAAIA,IAAI,GAAG,CAAC,CAAC;EACpC,CAAC,EAAE,CAAClB,SAAS,CAAC,CAAC;EAEf,MAAMsB,sBAAsB,GAAG5C,WAAW,CAAEwB,OAAyB,IAAK;IACtEY,OAAO,CAACS,GAAG,CAAC,6BAA6B,EAAErB,OAAO,CAAC;IAEnD,QAAQA,OAAO,CAACC,IAAI;MAChB,KAAK,cAAc;QACfa,eAAe,CAACd,OAAO,CAACK,IAAoB,CAAC;QAC7C;MACJ,KAAK,SAAS;QACVP,SAAS,CAAC,aAAa,EAAEE,OAAO,CAACK,IAAI,CAACiB,OAAO,EAAE,MAAM,CAAC;QACtD;MACJ,KAAK,MAAM;QACP;QACA;QACA;QACA;QACA;MACJ,KAAK,SAAS;MACd,KAAK,MAAM;QACP;MACJ;QACI;IACR;EACJ,CAAC,EAAE,CAACR,eAAe,EAAEhB,SAAS,CAAC,CAAC;EAEhC,MAAMyB,UAAU,GAAG,MAAOL,EAAU,IAAK;IACrC,IAAI;MACA,MAAMzC,mBAAmB,CAAC8C,UAAU,CAACL,EAAE,CAAC;MACxCzB,gBAAgB,CAACuB,IAAI,IAAIA,IAAI,CAACQ,GAAG,CAAChB,CAAC,IAAIA,CAAC,CAACU,EAAE,KAAKA,EAAE,GAAG;QAAE,GAAGV,CAAC;QAAEC,OAAO,EAAE;MAAK,CAAC,GAAGD,CAAC,CAAC,CAAC;MAClFb,cAAc,CAACqB,IAAI,IAAIS,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEV,IAAI,GAAG,CAAC,CAAC,CAAC;IACjD,CAAC,CAAC,OAAOL,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAAC,qCAAqC,EAAEF,GAAG,CAAC;IAC7D;EACJ,CAAC;EAED,MAAMgB,aAAa,GAAG,MAAAA,CAAA,KAAY;IAC9B,IAAI;MACA,MAAMlD,mBAAmB,CAACkD,aAAa,CAAC,CAAC;MACzClC,gBAAgB,CAACuB,IAAI,IAAIA,IAAI,CAACQ,GAAG,CAAChB,CAAC,KAAK;QAAE,GAAGA,CAAC;QAAEC,OAAO,EAAE;MAAK,CAAC,CAAC,CAAC,CAAC;MAClEd,cAAc,CAAC,CAAC,CAAC;IACrB,CAAC,CAAC,OAAOgB,GAAG,EAAE;MACVC,OAAO,CAACC,KAAK,CAAC,0CAA0C,EAAEF,GAAG,CAAC;IAClE;EACJ,CAAC;EAEDpC,SAAS,CAAC,MAAM;IACZ,IAAIG,WAAW,CAAC0B,eAAe,CAAC,CAAC,EAAE;MAC/BD,kBAAkB,CAAC,CAAC;MAEpB,MAAMyB,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;MAC3C,IAAIF,KAAK,EAAE;QACP1C,gBAAgB,CAAC6C,OAAO,CAACH,KAAK,CAAC;QAC/B,MAAMI,WAAW,GAAG9C,gBAAgB,CAAC+C,SAAS,CAACb,sBAAsB,CAAC;QACtE,OAAO,MAAM;UACTY,WAAW,CAAC,CAAC;UACb;UACA;QACJ,CAAC;MACL;IACJ,CAAC,MAAM;MACH9C,gBAAgB,CAACgD,UAAU,CAAC,CAAC;IACjC;EACJ,CAAC,EAAE,CAAC/B,kBAAkB,EAAEiB,sBAAsB,CAAC,CAAC;EAEhD,MAAMe,mBAAmB,GAAIlC,IAAY,IAAK;IAC1C,QAAQA,IAAI;MACR,KAAK,SAAS;QAAE,oBAAOb,OAAA,CAACR,WAAW;UAACwD,SAAS,EAAC;QAAwB;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC;MACzE,KAAK,MAAM;QAAE,oBAAOpD,OAAA,CAACP,IAAI;UAACuD,SAAS,EAAC;QAAuB;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC;MAC9D,KAAK,SAAS;QAAE,oBAAOpD,OAAA,CAACN,aAAa;UAACsD,SAAS,EAAC;QAAyB;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC;MAC5E,KAAK,OAAO;QAAE,oBAAOpD,OAAA,CAACL,WAAW;UAACqD,SAAS,EAAC;QAAsB;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC;MACrE;QAAS,oBAAOpD,OAAA,CAACT,IAAI;UAACyD,SAAS,EAAC;QAAuB;UAAAC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE,CAAC;IAC9D;EACJ,CAAC;EAED,MAAMC,0BAA0B,GAAIxC,IAAY,IAAK;IACjD,QAAQA,IAAI;MACR,KAAK,SAAS;QAAE,OAAO,kBAAkB;MACzC,KAAK,MAAM;QAAE,OAAO,iBAAiB;MACrC,KAAK,SAAS;QAAE,OAAO,mBAAmB;MAC1C,KAAK,OAAO;QAAE,OAAO,gBAAgB;MACrC;QAAS,OAAO,iBAAiB;IACrC;EACJ,CAAC;EAED,oBACIb,OAAA,CAACJ,mBAAmB,CAAC0D,QAAQ;IAACC,KAAK,EAAE;MACjCnD,aAAa;MACbE,WAAW;MACXoB,eAAe;MACfS,UAAU;MACVI,aAAa;MACbiB,OAAO,EAAEzC;IACb,CAAE;IAAAb,QAAA,EACGA;EAAQ;IAAA+C,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACiB,CAAC;AAEvC,CAAC;AAACjD,EAAA,CAlIWF,oBAA6D;AAAAwD,EAAA,GAA7DxD,oBAA6D;AAoI1E,OAAO,MAAMyD,gBAAgB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EAClC,MAAMC,OAAO,GAAG3E,UAAU,CAACW,mBAAmB,CAAC;EAC/C,IAAIgE,OAAO,KAAK/D,SAAS,EAAE;IACvB,MAAM,IAAIgE,KAAK,CAAC,6DAA6D,CAAC;EAClF;EACA,OAAOD,OAAO;AAClB,CAAC;AAACD,GAAA,CANWD,gBAAgB;AAAA,IAAAD,EAAA;AAAAK,YAAA,CAAAL,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}