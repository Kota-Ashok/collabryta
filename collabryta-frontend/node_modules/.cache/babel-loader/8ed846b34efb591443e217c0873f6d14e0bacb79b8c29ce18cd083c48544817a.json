{"ast":null,"code":"var _jsxFileName = \"D:\\\\Collabryta\\\\collabryta-frontend\\\\src\\\\context\\\\NotificationContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { notificationService } from '../services/notificationService';\nimport { authService } from '../services/authService';\n\n/**\r\n * Context interface for managing global application notifications.\r\n */\n\nconst NotificationContext = /*#__PURE__*/createContext(undefined);\nimport { webSocketService } from '../services/websocketService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const fetchNotifications = useCallback(async () => {\n    if (!authService.isAuthenticated()) return;\n    try {\n      const data = await notificationService.getNotifications(0, 50);\n      setNotifications(data);\n      setUnreadCount(data.filter(n => !n.is_read).length);\n    } catch (err) {\n      console.error('Error fetching notifications:', err);\n    }\n  }, []);\n  const addNotification = useCallback(notification => {\n    setNotifications(prev => {\n      // Check if notification already exists to avoid duplicates\n      if (prev.some(n => n.id === notification.id)) return prev;\n      return [notification, ...prev];\n    });\n    setUnreadCount(prev => prev + 1);\n  }, []);\n  const handleWebSocketMessage = useCallback(message => {\n    console.log('Received WebSocket message:', message);\n    switch (message.type) {\n      case 'notification':\n        addNotification(message.data);\n        break;\n      case 'message':\n        // You could add a specific notification for a new message\n        // Or just silent refresh some state.\n        // For now, let's treat it as a trigger to refresh if needed, \n        // but usually the Messages page will listen for this.\n        break;\n      case 'task':\n      case 'meeting':\n      case 'file':\n        // Treat these as triggers to potentially show a toast or refresh\n        // The backend already sends a 'notification' type for many of these anyway.\n        break;\n      default:\n        break;\n    }\n  }, [addNotification]);\n  const markAsRead = async id => {\n    try {\n      await notificationService.markAsRead(id);\n      setNotifications(prev => prev.map(n => n.id === id ? {\n        ...n,\n        is_read: true\n      } : n));\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    } catch (err) {\n      console.error('Error marking notification as read:', err);\n    }\n  };\n  const markAllAsRead = async () => {\n    try {\n      await notificationService.markAllAsRead();\n      setNotifications(prev => prev.map(n => ({\n        ...n,\n        is_read: true\n      })));\n      setUnreadCount(0);\n    } catch (err) {\n      console.error('Error marking all notifications as read:', err);\n    }\n  };\n  useEffect(() => {\n    if (authService.isAuthenticated()) {\n      fetchNotifications();\n      const token = localStorage.getItem('token');\n      if (token) {\n        webSocketService.connect(token);\n        const unsubscribe = webSocketService.subscribe(handleWebSocketMessage);\n        return () => {\n          unsubscribe();\n          // We don't necessarily want to disconnect here if the component unmounts/remounts\n          // but since NotificationProvider is usually top-level, it's fine.\n        };\n      }\n    } else {\n      webSocketService.disconnect();\n    }\n  }, [fetchNotifications, handleWebSocketMessage]);\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: {\n      notifications,\n      unreadCount,\n      addNotification,\n      markAsRead,\n      markAllAsRead,\n      refresh: fetchNotifications\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 110,\n    columnNumber: 9\n  }, this);\n};\n_s(NotificationProvider, \"BAFVVUzU/NWnIINpLYd/bKqDHEE=\");\n_c = NotificationProvider;\nexport const useNotifications = () => {\n  _s2();\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n_s2(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","notificationService","authService","NotificationContext","undefined","webSocketService","jsxDEV","_jsxDEV","NotificationProvider","children","_s","notifications","setNotifications","unreadCount","setUnreadCount","fetchNotifications","isAuthenticated","data","getNotifications","filter","n","is_read","length","err","console","error","addNotification","notification","prev","some","id","handleWebSocketMessage","message","log","type","markAsRead","map","Math","max","markAllAsRead","token","localStorage","getItem","connect","unsubscribe","subscribe","disconnect","Provider","value","refresh","fileName","_jsxFileName","lineNumber","columnNumber","_c","useNotifications","_s2","context","Error","$RefreshReg$"],"sources":["D:/Collabryta/collabryta-frontend/src/context/NotificationContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\r\nimport { notificationService, Notification } from '../services/notificationService';\r\nimport { authService } from '../services/authService';\r\n\r\n/**\r\n * Context interface for managing global application notifications.\r\n */\r\ninterface NotificationContextType {\r\n    notifications: Notification[];\r\n    unreadCount: number;\r\n    addNotification: (notification: Notification) => void;\r\n    markAsRead: (id: number) => Promise<void>;\r\n    markAllAsRead: () => Promise<void>;\r\n    refresh: () => Promise<void>;\r\n}\r\n\r\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\r\n\r\nimport { webSocketService, WebSocketMessage } from '../services/websocketService';\r\n\r\nexport const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n    const [notifications, setNotifications] = useState<Notification[]>([]);\r\n    const [unreadCount, setUnreadCount] = useState(0);\r\n\r\n    const fetchNotifications = useCallback(async () => {\r\n        if (!authService.isAuthenticated()) return;\r\n\r\n        try {\r\n            const data = await notificationService.getNotifications(0, 50);\r\n            setNotifications(data);\r\n            setUnreadCount(data.filter(n => !n.is_read).length);\r\n        } catch (err) {\r\n            console.error('Error fetching notifications:', err);\r\n        }\r\n    }, []);\r\n\r\n    const addNotification = useCallback((notification: Notification) => {\r\n        setNotifications(prev => {\r\n            // Check if notification already exists to avoid duplicates\r\n            if (prev.some(n => n.id === notification.id)) return prev;\r\n            return [notification, ...prev];\r\n        });\r\n        setUnreadCount(prev => prev + 1);\r\n    }, []);\r\n\r\n    const handleWebSocketMessage = useCallback((message: WebSocketMessage) => {\r\n        console.log('Received WebSocket message:', message);\r\n\r\n        switch (message.type) {\r\n            case 'notification':\r\n                addNotification(message.data as Notification);\r\n                break;\r\n            case 'message':\r\n                // You could add a specific notification for a new message\r\n                // Or just silent refresh some state.\r\n                // For now, let's treat it as a trigger to refresh if needed, \r\n                // but usually the Messages page will listen for this.\r\n                break;\r\n            case 'task':\r\n            case 'meeting':\r\n            case 'file':\r\n                // Treat these as triggers to potentially show a toast or refresh\r\n                // The backend already sends a 'notification' type for many of these anyway.\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }, [addNotification]);\r\n\r\n    const markAsRead = async (id: number) => {\r\n        try {\r\n            await notificationService.markAsRead(id);\r\n            setNotifications(prev => prev.map(n => n.id === id ? { ...n, is_read: true } : n));\r\n            setUnreadCount(prev => Math.max(0, prev - 1));\r\n        } catch (err) {\r\n            console.error('Error marking notification as read:', err);\r\n        }\r\n    };\r\n\r\n    const markAllAsRead = async () => {\r\n        try {\r\n            await notificationService.markAllAsRead();\r\n            setNotifications(prev => prev.map(n => ({ ...n, is_read: true })));\r\n            setUnreadCount(0);\r\n        } catch (err) {\r\n            console.error('Error marking all notifications as read:', err);\r\n        }\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (authService.isAuthenticated()) {\r\n            fetchNotifications();\r\n\r\n            const token = localStorage.getItem('token');\r\n            if (token) {\r\n                webSocketService.connect(token);\r\n                const unsubscribe = webSocketService.subscribe(handleWebSocketMessage);\r\n                return () => {\r\n                    unsubscribe();\r\n                    // We don't necessarily want to disconnect here if the component unmounts/remounts\r\n                    // but since NotificationProvider is usually top-level, it's fine.\r\n                };\r\n            }\r\n        } else {\r\n            webSocketService.disconnect();\r\n        }\r\n    }, [fetchNotifications, handleWebSocketMessage]);\r\n\r\n    return (\r\n        <NotificationContext.Provider value={{\r\n            notifications,\r\n            unreadCount,\r\n            addNotification,\r\n            markAsRead,\r\n            markAllAsRead,\r\n            refresh: fetchNotifications\r\n        }}>\r\n            {children}\r\n        </NotificationContext.Provider>\r\n    );\r\n};\r\n\r\nexport const useNotifications = () => {\r\n    const context = useContext(NotificationContext);\r\n    if (context === undefined) {\r\n        throw new Error('useNotifications must be used within a NotificationProvider');\r\n    }\r\n    return context;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}