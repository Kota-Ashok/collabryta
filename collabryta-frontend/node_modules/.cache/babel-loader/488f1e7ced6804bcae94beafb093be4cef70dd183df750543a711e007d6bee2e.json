{"ast":null,"code":"var _jsxFileName = \"D:\\\\Collabryta\\\\collabryta-frontend\\\\src\\\\context\\\\NotificationContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';\nimport { notificationService } from '../services/notificationService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst NotificationContext = /*#__PURE__*/createContext(undefined);\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const listeners = useRef({});\n  const subscribe = useCallback((type, callback) => {\n    if (!listeners.current[type]) {\n      listeners.current[type] = [];\n    }\n    listeners.current[type].push(callback);\n    return () => {\n      listeners.current[type] = listeners.current[type].filter(cb => cb !== callback);\n    };\n  }, []);\n  const fetchNotifications = useCallback(async () => {\n    const token = localStorage.getItem('token');\n    if (!token) return;\n    try {\n      const data = await notificationService.getNotifications(0, 50);\n      setNotifications(data);\n      setUnreadCount(data.filter(n => !n.is_read).length);\n    } catch (err) {\n      console.error('Error fetching notifications:', err);\n    }\n  }, []);\n  const addNotification = useCallback(notification => {\n    setNotifications(prev => [notification, ...prev]);\n    setUnreadCount(prev => prev + 1);\n  }, []);\n  const markAsRead = async id => {\n    try {\n      await notificationService.markAsRead(id);\n      setNotifications(prev => prev.map(n => n.id === id ? {\n        ...n,\n        is_read: true\n      } : n));\n      setUnreadCount(prev => Math.max(0, prev - 1));\n    } catch (err) {\n      console.error('Error marking as read:', err);\n    }\n  };\n  const markAllAsRead = async () => {\n    try {\n      await notificationService.markAllAsRead();\n      setNotifications(prev => prev.map(n => ({\n        ...n,\n        is_read: true\n      })));\n      setUnreadCount(0);\n    } catch (err) {\n      console.error('Error marking all as read:', err);\n    }\n  };\n  useEffect(() => {\n    if (!authService.isAuthenticated()) return;\n    fetchNotifications();\n    const token = localStorage.getItem('token');\n    if (!token) return;\n    const wsUrl = `ws://localhost:8000/api/v1/ws?token=${token}`;\n    let ws;\n    let reconnectTimeout;\n    const connect = () => {\n      if (!authService.isAuthenticated()) {\n        console.log('WS: Not authenticated, stopping reconnection');\n        return;\n      }\n      console.log('WS: Connecting...');\n      ws = new WebSocket(wsUrl);\n      ws.onopen = () => {\n        console.log('WS: Connected');\n      };\n      ws.onmessage = event => {\n        try {\n          const message = JSON.parse(event.data);\n          if (message.type && listeners.current[message.type]) {\n            listeners.current[message.type].forEach(cb => cb(message.data));\n          }\n          if (message.type === 'notification') {\n            addNotification(message.data);\n          }\n        } catch (err) {\n          console.error('WS: Error parsing message:', err);\n        }\n      };\n      ws.onclose = event => {\n        console.log('WS: Closed', event.code, event.reason);\n        if (event.code === 1008) {\n          console.log('WS: Policy violation (likely expired token)');\n          localStorage.removeItem('token');\n          window.location.href = '/';\n          return;\n        }\n        if (authService.isAuthenticated()) {\n          reconnectTimeout = setTimeout(connect, 5000);\n        }\n      };\n      ws.onerror = err => {\n        console.error('WS: Error', err);\n      };\n    };\n    connect();\n    return () => {\n      console.log('WS: Cleaning up');\n      if (ws) ws.close();\n      clearTimeout(reconnectTimeout);\n    };\n  }, [fetchNotifications, addNotification]);\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: {\n      notifications,\n      unreadCount,\n      addNotification,\n      markAsRead,\n      markAllAsRead,\n      subscribe\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 135,\n    columnNumber: 9\n  }, this);\n};\n_s(NotificationProvider, \"PsGDTdxaAgTfqrsi0zK4yPrEJLk=\");\n_c = NotificationProvider;\nexport const useNotifications = () => {\n  _s2();\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n_s2(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useRef","notificationService","jsxDEV","_jsxDEV","NotificationContext","undefined","NotificationProvider","children","_s","notifications","setNotifications","unreadCount","setUnreadCount","listeners","subscribe","type","callback","current","push","filter","cb","fetchNotifications","token","localStorage","getItem","data","getNotifications","n","is_read","length","err","console","error","addNotification","notification","prev","markAsRead","id","map","Math","max","markAllAsRead","authService","isAuthenticated","wsUrl","ws","reconnectTimeout","connect","log","WebSocket","onopen","onmessage","event","message","JSON","parse","forEach","onclose","code","reason","removeItem","window","location","href","setTimeout","onerror","close","clearTimeout","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useNotifications","_s2","context","Error","$RefreshReg$"],"sources":["D:/Collabryta/collabryta-frontend/src/context/NotificationContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';\r\nimport { notificationService, Notification } from '../services/notificationService';\r\n\r\ninterface NotificationContextType {\r\n    notifications: Notification[];\r\n    unreadCount: number;\r\n    addNotification: (notification: Notification) => void;\r\n    markAsRead: (id: number) => Promise<void>;\r\n    markAllAsRead: () => Promise<void>;\r\n    subscribe: (type: string, callback: (data: any) => void) => () => void;\r\n}\r\n\r\nconst NotificationContext = createContext<NotificationContextType | undefined>(undefined);\r\n\r\nexport const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n    const [notifications, setNotifications] = useState<Notification[]>([]);\r\n    const [unreadCount, setUnreadCount] = useState(0);\r\n    const listeners = useRef<{ [type: string]: ((data: any) => void)[] }>({});\r\n\r\n    const subscribe = useCallback((type: string, callback: (data: any) => void) => {\r\n        if (!listeners.current[type]) {\r\n            listeners.current[type] = [];\r\n        }\r\n        listeners.current[type].push(callback);\r\n        return () => {\r\n            listeners.current[type] = listeners.current[type].filter(cb => cb !== callback);\r\n        };\r\n    }, []);\r\n\r\n    const fetchNotifications = useCallback(async () => {\r\n        const token = localStorage.getItem('token');\r\n        if (!token) return;\r\n        try {\r\n            const data = await notificationService.getNotifications(0, 50);\r\n            setNotifications(data);\r\n            setUnreadCount(data.filter(n => !n.is_read).length);\r\n        } catch (err) {\r\n            console.error('Error fetching notifications:', err);\r\n        }\r\n    }, []);\r\n\r\n    const addNotification = useCallback((notification: Notification) => {\r\n        setNotifications(prev => [notification, ...prev]);\r\n        setUnreadCount(prev => prev + 1);\r\n    }, []);\r\n\r\n    const markAsRead = async (id: number) => {\r\n        try {\r\n            await notificationService.markAsRead(id);\r\n            setNotifications(prev => prev.map(n => n.id === id ? { ...n, is_read: true } : n));\r\n            setUnreadCount(prev => Math.max(0, prev - 1));\r\n        } catch (err) {\r\n            console.error('Error marking as read:', err);\r\n        }\r\n    };\r\n\r\n    const markAllAsRead = async () => {\r\n        try {\r\n            await notificationService.markAllAsRead();\r\n            setNotifications(prev => prev.map(n => ({ ...n, is_read: true })));\r\n            setUnreadCount(0);\r\n        } catch (err) {\r\n            console.error('Error marking all as read:', err);\r\n        }\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (!authService.isAuthenticated()) return;\r\n\r\n        fetchNotifications();\r\n\r\n        const token = localStorage.getItem('token');\r\n        if (!token) return;\r\n\r\n        const wsUrl = `ws://localhost:8000/api/v1/ws?token=${token}`;\r\n        let ws: WebSocket;\r\n        let reconnectTimeout: any;\r\n\r\n        const connect = () => {\r\n            if (!authService.isAuthenticated()) {\r\n                console.log('WS: Not authenticated, stopping reconnection');\r\n                return;\r\n            }\r\n\r\n            console.log('WS: Connecting...');\r\n            ws = new WebSocket(wsUrl);\r\n\r\n            ws.onopen = () => {\r\n                console.log('WS: Connected');\r\n            };\r\n\r\n            ws.onmessage = (event) => {\r\n                try {\r\n                    const message = JSON.parse(event.data);\r\n                    if (message.type && listeners.current[message.type]) {\r\n                        listeners.current[message.type].forEach(cb => cb(message.data));\r\n                    }\r\n                    if (message.type === 'notification') {\r\n                        addNotification(message.data);\r\n                    }\r\n                } catch (err) {\r\n                    console.error('WS: Error parsing message:', err);\r\n                }\r\n            };\r\n\r\n            ws.onclose = (event) => {\r\n                console.log('WS: Closed', event.code, event.reason);\r\n                if (event.code === 1008) {\r\n                    console.log('WS: Policy violation (likely expired token)');\r\n                    localStorage.removeItem('token');\r\n                    window.location.href = '/';\r\n                    return;\r\n                }\r\n\r\n                if (authService.isAuthenticated()) {\r\n                    reconnectTimeout = setTimeout(connect, 5000);\r\n                }\r\n            };\r\n\r\n            ws.onerror = (err) => {\r\n                console.error('WS: Error', err);\r\n            };\r\n        };\r\n\r\n        connect();\r\n\r\n        return () => {\r\n            console.log('WS: Cleaning up');\r\n            if (ws) ws.close();\r\n            clearTimeout(reconnectTimeout);\r\n        };\r\n    }, [fetchNotifications, addNotification]);\r\n\r\n    return (\r\n        <NotificationContext.Provider value={{ notifications, unreadCount, addNotification, markAsRead, markAllAsRead, subscribe }}>\r\n            {children}\r\n        </NotificationContext.Provider>\r\n    );\r\n};\r\n\r\nexport const useNotifications = () => {\r\n    const context = useContext(NotificationContext);\r\n    if (context === undefined) {\r\n        throw new Error('useNotifications must be used within a NotificationProvider');\r\n    }\r\n    return context;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}